<!DOCTYPE html>
<html lang="en"><head>
  <meta charset="utf-8">
  <meta http-equiv="X-UA-Compatible" content="IE=edge">
  <meta name="viewport" content="width=device-width, initial-scale=1"><!-- Begin Jekyll SEO tag v2.7.1 -->
<title>Memory efficient file streaming from AWS S3 | alebian’s blog</title>
<meta name="generator" content="Jekyll v4.1.1" />
<meta property="og:title" content="Memory efficient file streaming from AWS S3" />
<meta name="author" content="Alejandro Bezdjian" />
<meta property="og:locale" content="en_US" />
<meta name="description" content="Stream files from AWS S3 without downloading them completely" />
<meta property="og:description" content="Stream files from AWS S3 without downloading them completely" />
<link rel="canonical" href="https://blog.alebian.com/ruby/rails/aws/streams/s3/2020/12/03/memory-efficient-file-streaming-from-aws-s3.html" />
<meta property="og:url" content="https://blog.alebian.com/ruby/rails/aws/streams/s3/2020/12/03/memory-efficient-file-streaming-from-aws-s3.html" />
<meta property="og:site_name" content="alebian’s blog" />
<meta property="og:type" content="article" />
<meta property="article:published_time" content="2020-12-03T00:00:00-03:00" />
<meta name="twitter:card" content="summary" />
<meta property="twitter:title" content="Memory efficient file streaming from AWS S3" />
<script type="application/ld+json">
{"mainEntityOfPage":{"@type":"WebPage","@id":"https://blog.alebian.com/ruby/rails/aws/streams/s3/2020/12/03/memory-efficient-file-streaming-from-aws-s3.html"},"url":"https://blog.alebian.com/ruby/rails/aws/streams/s3/2020/12/03/memory-efficient-file-streaming-from-aws-s3.html","headline":"Memory efficient file streaming from AWS S3","dateModified":"2020-12-03T00:00:00-03:00","datePublished":"2020-12-03T00:00:00-03:00","author":{"@type":"Person","name":"Alejandro Bezdjian"},"description":"Stream files from AWS S3 without downloading them completely","@type":"BlogPosting","@context":"https://schema.org"}</script>
<!-- End Jekyll SEO tag -->
<link rel="stylesheet" href="/assets/main.css"><link type="application/atom+xml" rel="alternate" href="https://blog.alebian.com/feed.xml" title="alebian's blog" />
    <!-- Google Analytics -->
    <script>
    (function(i,s,o,g,r,a,m){i['GoogleAnalyticsObject']=r;i[r]=i[r]||function(){
    (i[r].q=i[r].q||[]).push(arguments)},i[r].l=1*new Date();a=s.createElement(o),
    m=s.getElementsByTagName(o)[0];a.async=1;a.src=g;m.parentNode.insertBefore(a,m)
    })(window,document,'script','https://www.google-analytics.com/analytics.js','ga');

    ga('create', 'UA-159130156-1', 'auto');
	ga('send', 'pageview', { 'page': location.pathname + location.search + location.hash});
	ga('set', 'anonymizeIp', false);
    </script>
    <!-- End Google Analytics -->
    </head>
<body><header class="site-header" role="banner">

  <div class="wrapper"><a class="site-title" rel="author" href="/">alebian&#39;s blog</a><nav class="site-nav">
        <input type="checkbox" id="nav-trigger" class="nav-trigger" />
        <label for="nav-trigger">
          <span class="menu-icon">
            <svg viewBox="0 0 18 15" width="18px" height="15px">
              <path d="M18,1.484c0,0.82-0.665,1.484-1.484,1.484H1.484C0.665,2.969,0,2.304,0,1.484l0,0C0,0.665,0.665,0,1.484,0 h15.032C17.335,0,18,0.665,18,1.484L18,1.484z M18,7.516C18,8.335,17.335,9,16.516,9H1.484C0.665,9,0,8.335,0,7.516l0,0 c0-0.82,0.665-1.484,1.484-1.484h15.032C17.335,6.031,18,6.696,18,7.516L18,7.516z M18,13.516C18,14.335,17.335,15,16.516,15H1.484 C0.665,15,0,14.335,0,13.516l0,0c0-0.82,0.665-1.483,1.484-1.483h15.032C17.335,12.031,18,12.695,18,13.516L18,13.516z"/>
            </svg>
          </span>
        </label>

        <div class="trigger"><a class="page-link" href="/about/">About</a><a class="page-link" href="/featured_content/">Featured content</a></div>
      </nav></div>
</header>
<main class="page-content" aria-label="Content">
      <div class="wrapper">
        <article class="post h-entry" itemscope itemtype="http://schema.org/BlogPosting">

  <header class="post-header">
    <h1 class="post-title p-name" itemprop="name headline">Memory efficient file streaming from AWS S3</h1>
    <p class="post-meta">
      <time class="dt-published" datetime="2020-12-03T00:00:00-03:00" itemprop="datePublished">Dec 3, 2020
      </time></p>
  </header>

  <div class="post-content e-content" itemprop="articleBody">
    <p>In my <a href="https://blog.alebian.com/ruby/rails/sql/2020/11/24/re-wheel-1-how-does-rails-find_each-work.html">previous post</a> I talked about how you could efficiently stream database rows for processing. This time I want to talk about how you can implement the same to process lines in a file. I am going to use the same principles here, so I recommend you to read that post.</p>

<p>If you have to process large files, you don’t want to load them completely in memory because you can run out of memory. Knowing how to efficiently read a file is an essential skill in any programming language and even though I am going to show you code in Ruby, I hope you can transfer the ideas of this post into your favourite programming language.</p>

<p><a href="https://blog.appsignal.com/2018/07/10/ruby-magic-slurping-and-streaming-files.html">This post</a> already covers very well the subject of file streaming in Ruby, so, in order to make it more interesting I am going to show you how you can stream a file stored in AWS S3 line by line without downloading it completely. Of course, for most cases, it’s probably a better idea to download the whole file and then process it, but let’s assume that there is a limit on the amount of disk you can use, or that you don’t want to wait until the whole file is downloaded to process it.</p>

<p>The title of the post lies a little bit, because we are going to download the file, but the idea is to download small pieces of it and discard them after processing. So the first thing we should know is how to download a piece of file from S3, fortunately we can do that using URI parameters according to <a href="https://docs.aws.amazon.com/AmazonS3/latest/API/API_GetObject.html">their documentation</a>. I will not make the requests by hand, instead I’ll use the official <a href="https://github.com/aws/aws-sdk-ruby/tree/master/gems/aws-sdk-s3">S3 gem</a>. The AWS documentation specifies that the range of the file must respect the <a href="https://www.w3.org/Protocols/rfc2616/rfc2616-sec14.html#sec14.35">RFC 2616</a> specification, so if we want to get the first 100 bytes of a file we have to do something like:</p>

<div class="language-ruby highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nb">require</span> <span class="s1">'aws-sdk-s3'</span>

<span class="k">def</span> <span class="nf">build_range</span><span class="p">(</span><span class="n">range_start</span><span class="p">,</span> <span class="n">range_end</span><span class="p">)</span>
  <span class="s2">"bytes=</span><span class="si">#{</span><span class="n">range_start</span><span class="si">}</span><span class="s2">-</span><span class="si">#{</span><span class="n">range_end</span><span class="si">}</span><span class="s2">"</span>
<span class="k">end</span>

<span class="n">object</span> <span class="o">=</span> <span class="no">Aws</span><span class="o">::</span><span class="no">S3</span><span class="o">::</span><span class="no">Resource</span><span class="p">.</span><span class="nf">new</span><span class="p">.</span><span class="nf">bucket</span><span class="p">(</span><span class="s1">'some-bucket'</span><span class="p">).</span><span class="nf">object</span><span class="p">(</span><span class="s1">'some-file'</span><span class="p">)</span>
<span class="n">object</span><span class="p">.</span><span class="nf">get</span><span class="p">(</span><span class="ss">range: </span><span class="n">build_range</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="mi">100</span><span class="p">)).</span><span class="nf">body</span><span class="p">.</span><span class="nf">read</span>
</code></pre></div></div>

<p>Great! With this we can have a buffer in memory that stores the downloaded bytes and work with that. Before going into the implementation, let’s consider the possible situations we can run into and think what we should do:</p>

<ol>
  <li>We download a slice of the file that contains a new line character: we just return the first part of the buffer and keep the rest.</li>
  <li>The downloaded bytes do not have a new line character: we have to keep downloading until we get a new line character or we reach the end of the file.</li>
  <li>Reached the end of the file: we return the remaining bytes of the buffer.</li>
</ol>

<p>Now that we have an idea of what to do I’ll show you my implementation:</p>

<div class="language-ruby highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">class</span> <span class="nc">RemoteFileIterator</span>
  <span class="kp">include</span> <span class="no">Enumerable</span>

  <span class="no">KILOBYTE</span> <span class="o">=</span> <span class="mi">1024</span>
  <span class="no">MEGABYTE</span> <span class="o">=</span> <span class="mi">1024</span> <span class="o">*</span> <span class="no">KILOBYTE</span>

  <span class="k">def</span> <span class="nf">initialize</span><span class="p">(</span><span class="n">file_name</span><span class="p">,</span> <span class="ss">new_line_character: </span><span class="s2">"</span><span class="se">\n</span><span class="s2">"</span><span class="p">,</span> <span class="ss">batch_size: </span><span class="no">MEGABYTE</span><span class="p">,</span> <span class="n">bucket</span><span class="p">:)</span>
    <span class="vi">@object</span> <span class="o">=</span> <span class="no">Aws</span><span class="o">::</span><span class="no">S3</span><span class="o">::</span><span class="no">Resource</span><span class="p">.</span><span class="nf">new</span><span class="p">.</span><span class="nf">bucket</span><span class="p">(</span><span class="n">bucket</span><span class="p">).</span><span class="nf">object</span><span class="p">(</span><span class="n">file_name</span><span class="p">)</span>
    <span class="vi">@content_length</span> <span class="o">=</span> <span class="vi">@object</span><span class="p">.</span><span class="nf">content_length</span>
    <span class="vi">@new_line_character</span> <span class="o">=</span> <span class="n">new_line_character</span>
    <span class="vi">@batch_size</span> <span class="o">=</span> <span class="n">batch_size</span>
    <span class="n">reset_cursors!</span>
  <span class="k">end</span>

  <span class="k">def</span> <span class="nf">each</span>
    <span class="k">if</span> <span class="nb">block_given?</span>
      <span class="k">while</span> <span class="p">(</span><span class="n">line</span> <span class="o">=</span> <span class="n">read_buffer_or_fetch!</span><span class="p">)</span>
        <span class="k">yield</span> <span class="n">line</span>
      <span class="k">end</span>
      <span class="n">reset_cursors!</span>
    <span class="k">else</span>
      <span class="n">to_enum</span><span class="p">(</span><span class="ss">:each</span><span class="p">)</span>
    <span class="k">end</span>
  <span class="k">end</span>

  <span class="kp">private</span>

  <span class="k">def</span> <span class="nf">reset_cursors!</span>
    <span class="vi">@cursor</span> <span class="o">=</span> <span class="mi">0</span>
    <span class="vi">@buffer</span> <span class="o">=</span> <span class="kp">nil</span>
  <span class="k">end</span>

  <span class="k">def</span> <span class="nf">read_buffer_or_fetch!</span>
    <span class="k">if</span> <span class="n">buffer_has_new_line_character?</span>
      <span class="n">take_line_from_buffer!</span>
    <span class="k">elsif</span> <span class="vi">@cursor</span> <span class="o">&lt;</span> <span class="vi">@content_length</span>
      <span class="vi">@buffer</span> <span class="o">=</span> <span class="p">(</span><span class="vi">@buffer</span> <span class="o">||</span> <span class="s1">''</span><span class="p">)</span> <span class="o">+</span> <span class="vi">@object</span><span class="p">.</span><span class="nf">get</span><span class="p">(</span><span class="ss">range: </span><span class="n">build_range!</span><span class="p">).</span><span class="nf">body</span><span class="p">.</span><span class="nf">read</span>
      <span class="n">read_buffer_or_fetch!</span>
    <span class="k">end</span>
  <span class="k">end</span>

  <span class="k">def</span> <span class="nf">buffer_has_new_line_character?</span>
    <span class="o">!</span><span class="n">buffers_new_line_character_idx</span><span class="p">.</span><span class="nf">nil?</span>
  <span class="k">end</span>

  <span class="k">def</span> <span class="nf">buffers_new_line_character_idx</span>
    <span class="vi">@buffer</span><span class="o">&amp;</span><span class="p">.</span><span class="nf">index</span><span class="p">(</span><span class="vi">@new_line_character</span><span class="p">)</span>
  <span class="k">end</span>

  <span class="k">def</span> <span class="nf">take_line_from_buffer!</span>
    <span class="n">new_line_character_idx</span> <span class="o">=</span> <span class="n">buffers_new_line_character_idx</span>
    <span class="n">line</span> <span class="o">=</span> <span class="vi">@buffer</span><span class="p">[</span><span class="mi">0</span><span class="o">..</span><span class="p">(</span><span class="n">new_line_character_idx</span> <span class="o">-</span> <span class="vi">@new_line_character</span><span class="p">.</span><span class="nf">size</span><span class="p">)]</span>
    <span class="vi">@buffer</span> <span class="o">=</span> <span class="vi">@buffer</span><span class="p">[(</span><span class="n">new_line_character_idx</span> <span class="o">+</span> <span class="vi">@new_line_character</span><span class="p">.</span><span class="nf">size</span><span class="p">)</span><span class="o">..-</span><span class="mi">1</span><span class="p">]</span>
    <span class="vi">@buffer</span> <span class="o">=</span> <span class="kp">nil</span> <span class="k">if</span> <span class="vi">@buffer</span><span class="p">.</span><span class="nf">empty?</span> <span class="c1"># Doing str[str.size..-1] returns ''</span>
    <span class="n">line</span>
  <span class="k">end</span>

  <span class="k">def</span> <span class="nf">build_range!</span>
    <span class="n">range_start</span> <span class="o">=</span> <span class="vi">@cursor</span>
    <span class="n">range_end</span> <span class="o">=</span> <span class="vi">@cursor</span> <span class="o">+</span> <span class="vi">@batch_size</span> <span class="o">-</span> <span class="mi">1</span>
    <span class="vi">@cursor</span> <span class="o">=</span> <span class="n">range_end</span> <span class="o">&gt;</span> <span class="vi">@content_length</span> <span class="p">?</span> <span class="vi">@content_length</span> <span class="p">:</span> <span class="p">(</span><span class="n">range_end</span> <span class="o">+</span> <span class="mi">1</span><span class="p">)</span>
    <span class="s2">"bytes=</span><span class="si">#{</span><span class="n">range_start</span><span class="si">}</span><span class="s2">-</span><span class="si">#{</span><span class="n">range_end</span><span class="si">}</span><span class="s2">"</span>
  <span class="k">end</span>
<span class="k">end</span>
</code></pre></div></div>

<p>As you can see it is very similar to the class in my previous post (I won’t explain the Enumerable tricks in this post again). The <code class="language-plaintext highlighter-rouge">build_range!</code> method is pretty much the same as the one I showed you in the beginning of this post, but it also keeps track of the cursor.</p>

<p>In the <code class="language-plaintext highlighter-rouge">take_line_from_buffer!</code> method we first find the position of the first new line character and then we split the buffer in two parts, returning the first one and keeping the last one in the buffer.</p>

<p>The <code class="language-plaintext highlighter-rouge">read_buffer_or_fetch!</code> method recursively fetches data until we find a new line or we downloaded all the file. There is another way of writing this without checking if <code class="language-plaintext highlighter-rouge">cursor &lt; content_length</code>:</p>

<div class="language-ruby highlighter-rouge"><div class="highlight"><pre class="highlight"><code>  <span class="k">def</span> <span class="nf">each</span>
    <span class="o">...</span>
    <span class="k">while</span> <span class="p">(</span><span class="n">line</span> <span class="o">=</span> <span class="n">next_line!</span><span class="p">)</span>
      <span class="k">yield</span> <span class="n">line</span>
    <span class="k">end</span>
    <span class="o">...</span>
  <span class="k">end</span>

  <span class="k">def</span> <span class="nf">next_line!</span>
    <span class="n">read_buffer_or_fetch</span>
  <span class="k">rescue</span> <span class="no">Aws</span><span class="o">::</span><span class="no">S3</span><span class="o">::</span><span class="no">Errors</span><span class="o">::</span><span class="no">InvalidRange</span> <span class="o">=&gt;</span> <span class="n">_e</span>
    <span class="c1"># Since we don't check if we ask for bytes outside the length</span>
    <span class="c1"># we can take advantage of the exception thrown by the AWS gem</span>
    <span class="n">final_line</span> <span class="o">=</span> <span class="vi">@buffer</span>
    <span class="vi">@buffer</span> <span class="o">=</span> <span class="kp">nil</span>
    <span class="n">final_line</span>
  <span class="k">end</span>

  <span class="k">def</span> <span class="nf">read_buffer_or_fetch</span>
    <span class="k">if</span> <span class="n">buffer_has_new_line_character?</span>
      <span class="n">take_line_from_buffer!</span>
    <span class="k">else</span> <span class="c1"># Removed the condition</span>
      <span class="o">...</span>
    <span class="k">end</span>
  <span class="k">end</span>
</code></pre></div></div>

<p>Both implementations work but I prefer to avoid using exceptions for control flow because I consider that an anti-pattern.</p>

<p>As a final thougth, it’s worth noting that if you use this implementation with a file that does not have a new line character you will end up downloading the whole file in memory (which is what we wanted to avoid). For those cases you should consider other techniques that are outside of the scope of this post.</p>

<h3 id="conclusions">Conclusions</h3>

<p>Even though this might not be a great idea for regular files (since it makes several requests to download), this might be useful in specific use cases, for example if you have no disk space (or very little) or if the files you have to work with are very large and the download takes too much time (or fails) while your processing workers are idle in the meantime.</p>


<style>
  .bmc-button img {
    height: 34px !important;
    width: 35px !important;
    margin-bottom: 1px !important;
    box-shadow: none !important;
    border: none !important;
    vertical-align: middle !important;
  }

  .bmc-button {
    padding: 7px 10px 7px 10px !important;
    line-height: 35px !important;
    height: 51px !important;
    min-width: 217px !important;
    text-decoration: none !important;
    display: inline-flex !important;
    color: #ffffff !important;
    background-color: #5F7FFF !important;
    border-radius: 5px !important;
    border: 1px solid transparent !important;
    padding: 7px 10px 7px 10px !important;
    font-size: 28px !important;
    letter-spacing: 0.6px !important;
    box-shadow: 0px 1px 2px rgba(190, 190, 190, 0.5) !important;
    -webkit-box-shadow: 0px 1px 2px 2px rgba(190, 190, 190, 0.5) !important;
    margin: 0 auto !important;
    font-family: 'Cookie', cursive !important;
    -webkit-box-sizing: border-box !important;
    box-sizing: border-box !important;
    -o-transition: 0.3s all linear !important;
    -webkit-transition: 0.3s all linear !important;
    -moz-transition: 0.3s all linear !important;
    -ms-transition: 0.3s all linear !important;
    transition: 0.3s all linear !important;
  }

  .bmc-button:hover,
  .bmc-button:active,
  .bmc-button:focus {
    -webkit-box-shadow: 0px 1px 2px 2px rgba(190, 190, 190, 0.5) !important;
    text-decoration: none !important;
    box-shadow: 0px 1px 2px 2px rgba(190, 190, 190, 0.5) !important;
    opacity: 0.85 !important;
    color: #ffffff !important;
  }
</style>
<link href="https://fonts.googleapis.com/css?family=Cookie" rel="stylesheet">
<a class="bmc-button" target="_blank" href="https://www.buymeacoffee.com/alebian">
  <img src="https://cdn.buymeacoffee.com/buttons/bmc-new-btn-logo.svg" alt="Buy me a coffee">
  <span style="margin-left:15px;font-size:28px !important;">
    Buy me a coffee
  </span>
</a>


  </div><a class="u-url" href="/ruby/rails/aws/streams/s3/2020/12/03/memory-efficient-file-streaming-from-aws-s3.html" hidden></a>
</article>

      </div>
    </main><footer class="site-footer h-card">
  <data class="u-url" href="/"></data>

  <div class="wrapper">

    <h2 class="footer-heading">alebian&#39;s blog</h2>

    <div class="footer-col-wrapper">
      <div class="footer-col footer-col-1">
        <ul class="contact-list">
          <li class="p-name">Alejandro Bezdjian</li><li><a class="u-email" href="mailto:alebezdjian@gmail.com">alebezdjian@gmail.com</a></li></ul>
      </div>

      <div class="footer-col footer-col-2"><ul class="social-media-list"><li><a href="https://github.com/alebian"><svg class="svg-icon"><use xlink:href="/assets/minima-social-icons.svg#github"></use></svg> <span class="username">alebian</span></a></li><li><a href="https://www.linkedin.com/in/alebian"><svg class="svg-icon"><use xlink:href="/assets/minima-social-icons.svg#linkedin"></use></svg> <span class="username">alebian</span></a></li><li><a href="https://www.twitter.com/alebezdjian"><svg class="svg-icon"><use xlink:href="/assets/minima-social-icons.svg#twitter"></use></svg> <span class="username">alebezdjian</span></a></li></ul>
</div>

      <div class="footer-col footer-col-3">
        <p>Alejandro Bezdjian&#39;s technical blog about programming.</p>
      </div>
    </div>

  </div>

</footer>
</body>

</html>
